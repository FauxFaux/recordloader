<html xmlns="http://www.w3.org/1999/xhtml">
<!--
/*
 * Copyright (c)2005-2007 Mark Logic Corporation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * The use of the Apache License does not indicate that this project is
 * affiliated with the Apache Software Foundation.
 */
-->
<head>
<title>RecordLoader README</title>
<style>
td
{
  vertical-align: top;
}
</style>
</head>
<body>
<h1>RecordLoader</h1>

<p>
To get started with RecordLoader, try the
<a href="http://developer.marklogic.com/howto/tutorials/2006-06-recordloader.xqy">tutorial</a>.
</p>

<h2>Running RecordLoader</h2>
<p>The entry point is the main method in the
 com.marklogic.ps.RecordLoader class.
It takes zero or more property files as its arguments.
Any specified system properties will override file-based properties,
and properties found in later files may override properties
specified in earlier files on the command line.
It's also possibly to specify properties as VM arguments (-DNAME=value).
See
<code><a href="src/recordloader.sh">src/recordloader.sh</a></code>
for a sample shell script.
See <code><a href="src/config">src/config/</a></code>
for sample property files.
</p>

<h2>Required JVM: Sun 1.5 or later</h2>

<h2>Required libraries:</h2>
<ul>
  <li/>RecordLoader <a href="../releases/recordloader.jar">recordloader.jar</a>
  <li/>MarkLogic <a href="http://developer.marklogic.com/">XCC</a>
  <li/><a href="http://www.extreme.indiana.edu/xgws/xsoap/xpp/">XPP3</a>
  XML Pull-Parser
  (here's a link to the
  <a href="http://www.extreme.indiana.edu/dist/java-repository/xpp3/jars/">jar
  files</a> - be sure to use xpp3-1.1.4c.jar or later)
</ul>

<h2>Required inputs:</h2>
<p>
None. If <code>ID_NAME</code> is missing,
then the default value <code>#FILENAME</code> will be used.
</p>

<h2>Available properties:</h2>
<table border="1">
<tr><th>Property</th><th>default value</th><th>notes</th></tr>

<tr><td>CONNECTION_STRING</td><td>xcc://admin:admin@localhost:9000/</td>
<td>XCC URI, including username, password, host, and port,
to use for all queries and inserts.
  If desired, a database name may also be supplied.</td>
</tr>

<tr><td>DEFAULT_NAMESPACE</td><td>null</td>
<td>If present, all XML will default to the supplied namespace uri.</td>
</tr>

<tr><td>DOCUMENT_FORMAT</td><td>xml</td>
<td>Document format for all new documents.
  Valid settings are
  <code>xml</code>, <code>text()</code>, and <code>binary()</code>
</td>
</tr>

<tr><td>ERROR_EXISTING</td><td>false</td>
<td>If true, RecordLoader will exit with an error
  if it finds itself trying to overwrite an existing document uri.</td>
</tr>

<tr><td>FATAL_ERRORS</td><td>true</td>
<td>If true, RecordLoader will exit with an error
  upon encountering any non-retryable error.
  If set to false, RecordLoader will close the current record
  and continue on to the next.
</td>
</tr>

<tr><td>ID_NAME</td><td><code>#FILENAME</code></td>
<td>Required parameter: the text value of any element with this local-name
(or attribute value if ID_NAME starts with '@')
will be used to compose the final document uri.
Note that namespace is ignored: only the local-name is used.
<br/>
The special value <code>ID_NAME=#AUTO</code> will cause RecordLoader
to automatically generate ids, in sequence, for each input record.
Since RecordLoader automatically includes the base filename
in each output URI, this is safe.
Note that when the input is standard input,
the default value is <code>#AUTO</code> - not <code>#FILENAME</code>.
<br/>
The special value <code>ID_NAME=#FILENAME</code> will cause RecordLoader
to automatically load each input file into
a single document per input file, using the file's basename
as the record id.
<br/>
Examples: ID_NAME=MedlineID, ID_NAME=@id</td>
</tr>

<tr><td>IGNORE_UNKNOWN</td><td>false</td>
<td>If set, RecordLoader will ignore siblings of RECORD_NAME
that are not RECORD_NAME elements.
Otherwise, this condition causes a fatal error.</td>
</tr>

<tr><td>INPUT_MALFORMED_ACTION</td><td>REPORT</td>
<td>Constant values from java.nio.charset.CodingErrorAction,
used to determine what happens if there are
invalid character sequences in the input XML.
<ul>
<li/>REPORT: throws a MalformedInputException
<li/>REPLACE: replaces invalid sequence with a '?' or similar.
<li/>IGNORE: skips over the invalid sequence.
</ul>
</td>
</tr>

<tr><td>INPUT_ENCODING</td><td>UTF-8</td>
<td>The Java Charset encoding (codepage) to use for all input XML.
If unset, RecordLoader will use null,
which will default to the default Locale's character encoding.
<br/>
Note that MarkLogic Server must receive all XML as UTF-8,
so the output encoding is always UTF-8.
<br/>
<b>Example</b>: if the input XML is encoded as <code>windows-1252</code>,
use <code>INPUT_ENCODING=Cp1252</code> to ensure correct conversion.
</td>
</tr>

<tr><td>INPUT_PATH</td><td>null</td>
<td>The filesystem path in which to look for XML files or zip archives.
If unset, RecordLoader will read XML directly from standard input.</td>
</tr>

<tr><td>INPUT_PATTERN</td><td>^.+\\.[Xx][Mm][Ll]$</td>
<td>Matching pattern (regex) for files found in INPUT_PATH.
The default value matches all filenames ending with <code>.xml</code></td>
</tr>

<tr><td>INPUT_STRIP_PREFIX</td><td>null</td>
<td>If not null, characters matching this pattern (regex)
  will be removed from all input URIs.
  For example, Windows users may wish to set
  <code>INPUT_STRIP_PREFIX=^[A-Z]:</code>
  so that document URIs in the database
  do not include drive-letter prefixes.
</td>
</tr>

<tr><td>INPUT_NORMALIZE_PATHS</td><td>false</td>
<td>If true, backslashes in input paths
  will be coalesced and replaced with slashes
  in all output document URIs.
  This is useful for Windows users,
  especially in combination with <code>INPUT_STRIP_PREFIX</code>.
  With both properties set as suggested,
  <code>C:\foo\bar\baz.xml</code> on the filesystem becomes
  <code>/foo/bar/baz.xml</code> in the database.
</td>
</tr>

<tr>
  <td>LOG_LEVEL</td><td>INFO</td>
  <td>java.util.logger.Level at which to log.</td>
</tr>

<tr>
  <td>LOG_HANDLER</td><td>CONSOLE,FILE</td>
  <td>java.util.logger log handlers with which to log.</td>
</tr>

<tr><td>OUTPUT_COLLECTIONS</td><td>null</td>
<td>One or more collections to apply to every new document.
Use whitespace to separate multiple collection uris.</td>
</tr>

<tr><td>OUTPUT_FORESTS</td><td>null</td>
<td>If set, all documents will be explicitly placed into the named forests.
Use whitespace or the characters <code>,:;</code> to separate values.</td>
</tr>

<tr><td>READ_ROLES</td><td>null</td>
<td>One or more existing role name, separated by whitespace.
If set, every document inserted by RecordLoader
will have read permission for these roles.
If any of the supplied role-names do not exist,
the first document insert will throw a fatal error.</td>
</tr>

<tr><td>RECORD_NAME</td><td>null</td>
<td>Element name in which each document is found. These may not nest.
If no RECORD_NAME is set, the first child element
of the first root element
will be used for the entire RecordLoader run.</td>
</tr>

<tr><td>RECORD_NAMESPACE</td><td>null</td>
<td>Element namespace in which each document is found.
If unset, but RECORD_NAME is set, then the empty namespace is assumed.
If unset, and RECORD_NAME is also unset,
then then the namespace of the first child element
of the first root element
will be used for the entire RecordLoader run.</td>
</tr>

<tr><td>SKIP_EXISTING</td><td>false</td>
<td>If true, existing document uris will be skipped.
This allows RecordLoader to resume after being interrupted.
Note that one read I/O is required per skip,
so SKIP_EXISTING is slower than using START_ID (below).
The two properties may be combined,
in case the known value for START_ID already exists.
</td>
</tr>

<tr><td>START_ID</td><td>null</td>
<td>When set, records are skipped
until one with an ID_NAME value equal to START_ID is found.
This allows RecordLoader to resume after being interrupted.</td>
</tr>

<tr><td>THREADS</td><td>1</td>
<td>Number of RecordLoader threads.
Note that when using standard input, this value is ignored.</td>
</tr>

<tr><td>THROTTLE_EVENTS_PER_SECOND</td><td>0</td>
<td>If non-zero, all threads will be throttled
  to the given number of inserts per second.</td>
</tr>

<tr><td>URI_PREFIX</td><td>null</td>
<td>Prefix used before the ID_NAME value, to compose all document uris.
If the prefix does not end in '/', RecordLoader will add a '/' to it.
</td>
</tr>

<tr><td>URI_SUFFIX</td><td>null</td>
<td>Suffix used after the ID_NAME value, to compose all document uris.</td>
</tr>

<tr><td>XML_REPAIR_LEVEL</td><td>NONE</td>
<td>To what degree should XPP3 and MarkLogic Server
compensate for invalid XML?
<ul>
<li/>NONE: throw a fatal exception.
<li/>FULL: do everything reasonable to ingest the document.
</ul>
</td>
</tr>

</table>

<h2>Troubleshooting</h2>
<p><code>XmlPullParserException: could not resolve entity named 'foo'</code>.
The XPP implementation used by RecordLoader, xpp3,
does not handle unknown references,
and does not process DTD-style document declarations.
So if your XML includes non-XML character entities,
RecordLoader is not for you.
Future enhancements could include a plug-in system,
allowing the user to substitute an XPP implementation
that supports document declarations.
</p>
<p><code>java.util.concurrent.RejectedExecutionException</code>.
If you're using RecordLoader with thousands of files or zipfile entries,
you may need to increase the JVM heap space. Try <code>-Xmx256m</code>
as one of your command-line JVM arguments.
</p>
</body>
</html>
